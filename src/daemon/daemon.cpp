/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

#include "daemon.h"
#include "leakdetector.h"
#include "logger.h"
#include "loghandler.h"

#include <QCoreApplication>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>
#include <QTimer>

constexpr const char* JSON_ALLOWEDIPADDRESSRANGES = "allowedIPAddressRanges";

namespace {

Logger logger(LOG_MAIN, "Daemon");

Daemon* s_daemon = nullptr;

}  // namespace

Daemon::Daemon(QObject* parent) : QObject(parent) {
  MVPN_COUNT_CTOR(Daemon);

  logger.log() << "Daemon created";

  Q_ASSERT(s_daemon == nullptr);
  s_daemon = this;
}

Daemon::~Daemon() {
  MVPN_COUNT_DTOR(Daemon);

  logger.log() << "Daemon released";

  Q_ASSERT(s_daemon == this);
  s_daemon = nullptr;
}

// static
Daemon* Daemon::instance() {
  Q_ASSERT(s_daemon);
  return s_daemon;
}

bool Daemon::activate(const InterfaceConfig& config) {
  // There are 3 possible scenarios in which this method is called:
  //
  // 1. the VPN is off: the method tries to enable the VPN.
  // 2. the VPN is on and the platform doesn't support the server-switching:
  //    this method calls deactivate() and then it continues as 1.
  // 3. the VPN is on and the platform supports the server-switching: this
  //    method calls switchServer().
  //
  // At the end, if the activation succeds, the `connected` signal is emitted.
  const QString ifname = interfaceName(config.m_hopindex);
  logger.log() << "Activating interface" << ifname;

  if (m_connections.contains(config.m_hopindex)) {
    if (supportServerSwitching(config)) {
      logger.log() << "Already connected. Server switching supported.";

      m_connections[config.m_hopindex] = ConnectionState(config);
      if (!switchServer(config)) {
        return false;
      }

      emit connected(config.m_hopindex);
      return true;
    }

    logger.log() << "Already connected. Server switching not supported.";
    if (!deactivate(false)) {
      return false;
    }

    Q_ASSERT(!m_connections.contains(config.m_hopindex));
    return activate(config);
  }

  if (supportWGUtils()) {
    if (wgutils()->interfaceExists(ifname)) {
      logger.log() << "Wireguard interface" << ifname << "already exists.";
      return false;
    }
    // add_if
    if (!wgutils()->addInterface(config)) {
      return false;
    }
    // set conf
    if (!wgutils()->configureInterface(config)) {
      return false;
    }
  }
  if ((config.m_hopindex == 0) && supportDnsUtils()) {
    QList<QHostAddress> resolvers;
    resolvers.append(QHostAddress(config.m_serverIpv4Gateway));
    if (config.m_ipv6Enabled) {
      resolvers.append(QHostAddress(config.m_serverIpv6Gateway));
    }
    if (!dnsutils()->updateResolvers(ifname, resolvers)) {
      return false;
    }
  }
  if (supportIPUtils()) {
    if (!iputils()->addInterfaceIPs(config)) {
      return false;
    }
    if (!iputils()->setMTUAndUp(config)) {
      return false;
    }
  }
  if (supportWGUtils()) {
    // set routing
    for (const IPAddressRange& ip : config.m_allowedIPAddressRanges) {
      if (!wgutils()->addRoutePrefix(ip, ifname)) {
        logger.log() << "Routing configuration failed for" << ifname;
        return false;
      }
    }
  }

  bool status = run(Up, config);
  logger.log() << "Connection" << ifname << "status:" << status;
  if (status) {
    m_connections[config.m_hopindex] = ConnectionState(config);
    emit connected(config.m_hopindex);
  }

  return status;
}

bool Daemon::parseConfig(const QJsonObject& jsonConfig,
                         InterfaceConfig& config) {
#define GETVALUESTR(from, name, where)                         \
  if (!from.contains(name)) {                                  \
    logger.log() << name << " missing in the " #from " input"; \
    return false;                                              \
  }                                                            \
  {                                                            \
    QJsonValue value = from.value(name);                       \
    if (!value.isString()) {                                   \
      logger.log() << name << " is not a string";              \
      return false;                                            \
    }                                                          \
    where = value.toString();                                  \
  }

  GETVALUESTR(jsonConfig, "privateKey", config.m_privateKey);
  GETVALUESTR(jsonConfig, "deviceIpv4Address", config.m_deviceIpv4Address);
  GETVALUESTR(jsonConfig, "deviceIpv6Address", config.m_deviceIpv6Address);
  GETVALUESTR(jsonConfig, "serverIpv4Gateway", config.m_serverIpv4Gateway);
  GETVALUESTR(jsonConfig, "serverIpv6Gateway", config.m_serverIpv6Gateway);
  GETVALUESTR(jsonConfig, "serverPublicKey", config.m_serverPublicKey);
  GETVALUESTR(jsonConfig, "serverIpv4AddrIn", config.m_serverIpv4AddrIn);
  GETVALUESTR(jsonConfig, "serverIpv6AddrIn", config.m_serverIpv6AddrIn);

#define GETVALUEINT(from, name, where)                         \
  if (!from.contains(name)) {                                  \
    logger.log() << name << " missing in the " #from " input"; \
    return false;                                              \
  }                                                            \
  {                                                            \
    QJsonValue value = from.value(name);                       \
    if (!value.isDouble()) {                                   \
      logger.log() << name << " is not a number";              \
      return false;                                            \
    }                                                          \
    where = value.toInt();                                     \
  }

  GETVALUEINT(jsonConfig, "serverPort", config.m_serverPort);

#define GETVALUEBOOL(from, name, where)                        \
  if (!from.contains(name)) {                                  \
    logger.log() << name << " missing in the " #from " input"; \
    return false;                                              \
  }                                                            \
  {                                                            \
    QJsonValue value = from.value(name);                       \
    if (!value.isBool()) {                                     \
      logger.log() << name << " is not a boolean";             \
      return false;                                            \
    }                                                          \
    where = value.toBool();                                    \
  }

  GETVALUEBOOL(jsonConfig, "ipv6Enabled", config.m_ipv6Enabled);

  if (!jsonConfig.contains("hopindex")) {
    config.m_hopindex = 0;
  } else {
    QJsonValue value = jsonConfig.value("hopindex");
    if (!value.isDouble()) {
      logger.log() << "hopindex is not a number";
      return false;
    }
    config.m_hopindex = value.toInt();
  }
  config.m_ifname = interfaceName(config.m_hopindex);

  if (!jsonConfig.contains(JSON_ALLOWEDIPADDRESSRANGES)) {
    logger.log() << JSON_ALLOWEDIPADDRESSRANGES
                 << "missing in the jsonconfig input";
    return false;
  }
  {
    QJsonValue value = jsonConfig.value(JSON_ALLOWEDIPADDRESSRANGES);
    if (!value.isArray()) {
      logger.log() << JSON_ALLOWEDIPADDRESSRANGES << "is not an array";
      return false;
    }

    QJsonArray array = value.toArray();
    for (QJsonValue i : array) {
      if (!i.isObject()) {
        logger.log() << JSON_ALLOWEDIPADDRESSRANGES
                     << "must contain only objects";
        return false;
      }

      QJsonObject ipObj = i.toObject();

      QJsonValue address = ipObj.value("address");
      if (!address.isString()) {
        logger.log() << JSON_ALLOWEDIPADDRESSRANGES
                     << "objects must have a string address";
        return false;
      }

      QJsonValue range = ipObj.value("range");
      if (!range.isDouble()) {
        logger.log() << JSON_ALLOWEDIPADDRESSRANGES
                     << "object must have a numberic range";
        return false;
      }

      QJsonValue isIpv6 = ipObj.value("isIpv6");
      if (!isIpv6.isBool()) {
        logger.log() << JSON_ALLOWEDIPADDRESSRANGES
                     << "object must have a boolean isIpv6";
        return false;
      }

      if (isIpv6.toBool() && !config.m_ipv6Enabled) {
        continue;
      }

      config.m_allowedIPAddressRanges.append(IPAddressRange(
          address.toString(), range.toInt(),
          isIpv6.toBool() ? IPAddressRange::IPv6 : IPAddressRange::IPv4));
    }
  }

#undef GETVALUESTR
#undef GETVALUEINT
#undef GETVALUEBOOL
  return true;
}

bool Daemon::deactivate(int hopindex, bool emitSignals) {
  QString ifname = interfaceName(hopindex);
  logger.log() << "Deactivating interface" << ifname;

  if (!m_connections.contains(hopindex)) {
    logger.log() << "Wireguard interface" << ifname << "does not exist.";
    return false;
  }

  const InterfaceConfig& config = m_connections.value(hopindex).m_config;
  bool status = run(Down, config);

  if ((hopindex == 0) && supportDnsUtils()) {
    if (!dnsutils()->restoreResolvers()) {
      return false;
    }
  }

  if (supportWGUtils()) {
    if (!wgutils()->interfaceExists(config.m_ifname)) {
      logger.log() << "Wireguard interface" << config.m_ifname
                   << "does not exist.";
      return false;
    }
    if (!wgutils()->deleteInterface(config.m_ifname)) {
      return false;
    }
  }
  m_connections.remove(hopindex);

  // No notification for server switching.
  if (emitSignals && status) {
    emit disconnected(hopindex);
  }

  return status;
}

bool Daemon::deactivateAll(bool emitSignals) {
  for (int hopindex : m_connections.keys()) {
    deactivate(hopindex, emitSignals);
  }
  return true;
}

QString Daemon::logs() {
  QString output;

  {
    QTextStream out(&output);
    LogHandler::writeLogs(out);
  }

  return output;
}

void Daemon::cleanLogs() { LogHandler::instance()->cleanupLogs(); }

bool Daemon::switchServer(const InterfaceConfig& config) {
  Q_UNUSED(config);
  qFatal("Have you forgotten to implement switchServer?");
  return false;
}
